# 前言

一直以来，对于后台基于gRPC开发的开发人员，与前端匹配都是一件繁琐的事情。在多终端场景下，前端代码的实际运行环境往往存在诸多限制，这决定了前端通常要选用最通用最常规的通信方案，所以直接使用gRPC与后台通信几乎不可能。

那么，如何完成常见的HTTP/HTTPS+JSON与gRPC的协议转换，在开源界产生了众多处理方案，下面我会先简单回顾下开源界的主流方案，并讲解我们的解决方案。

# 主流开源方案总结

## **插件方案**



插件方案本身又细分为集成插件方案和多进程插件，但是本质是一样的。就是在转发时，基于服务端的IDL信息，实现相应的客户端，然后进行协议转换和转发，区别在于客户端处在网关中（集成插件）还是独立在外面以独立进程运行（多进程插件）。

这一方案较为常见，虽然有各种各样的实现方式，但内涵趋同。该方案常见于业务自行实现的业务网关，在比较著名的开源项目如Tyk，Traefik中也有使用。

优点：

- 实现简单，无技术难点
- 对前后端无侵入

缺点：

- 协议转换组件高度耦合业务proto，难以维护

## **gRPC-Bridge方案**



该名称出自envoy，但是代表了一类方案，我们这里把他们统称为GRPC-bridge方案。这类方案的原理是：把序列化的任务交还给客户端，然后用普通的HTTP/HTTPS请求将数据送到网关，然后由API网关取出该序列化结果，升级成HTTP2跟后台相应的GRPC服务交互。类似的实现还有grpc-web等。

优点：

- 对后端无侵入
- 网关可以实现通用功能

缺点：

- 对前端侵入大，前端必须感知协议变化，并完成序列化

## **gRPC-Gateway方案**

这个方案的基本原理是通过代码生成来自动生成每个配置了的gRPC接口的对应的HTTP接口。使用时，后台开发需要在proto文件中添加大量配置，之后，后台服务可以作为一个HTTP服务对网关暴露。本质上类似于多进程方案，主要亮点是基于代码生成。

优点：

- 对前端和网关无侵入

缺点：

- 网关与后端之间降级为HTTP1.1，性能不如HTTP2
- proto引入额外的外部依赖，google.api.http包
- 对后台开发人员侵入较大，接口规模大时，难以维护

## 总结

在目前主流的gRPC的协议转换方案一定程度上都需要入侵前端或者后端，带来了额外的维护成本。伴随着接口越来越多，服务越来越细分，这些维护成本会逐渐大到无法承受。

# 基于反射协议的gRPC协议转换

<img src="../../../../images/01 微保 API 网关的探索与实践/image2020-8-10_18-27-38.png" alt="image2020-8-10_18-27-38" style="zoom:80%;" />

gRPC协议转换之所以困难，是因为序列化的过程强依赖于IDL文件的描述。必须依赖响应服务的proto文件，才能正常的完成序列化。所以，问题的关键在于：

1. 服务的IDL信息能否在运行时获得
2. 根据运行时获得的IDL信息能否在运行时构造请求参数和解析返回参数

带着这两个问题，我们在调研中发现了gRPC的反射协议。gRPC反射协议本身也是一种RPC服务，客户端可以通过访问该服务，获得服务端对外暴露的接口详情，包括服务名，函数列表，出入参数等等信息。

这样依赖反射协议，我们就能够获取服务端的IDL信息，接下来只要找到根据相应的IDL信息进行序列化和反序列化的方法，就可以实现gRPC的泛化调用。gRPC反射协议原理和具体实现方法较为复杂，限于篇幅我们这里不详细描述，后续会在其他文章中详细解析实现过程。

此外，因为服务的协议信息相对稳定，我们在实现时通过异步拉取，缓存协议信息的方式，优化了泛化调用的性能。该方法有如下优点：

1. 官方原生支持反射协议，且支持多语言，跨语言，跨平台
2. 后端改造极小，前端无需感知，API网关一次性实现无后续维护成本
3. 协议更新自动化，无需配置，业务无感知，无后续维护成本



参考资料 

微保 API 网关的探索与实践 https://mp.weixin.qq.com/s/OTyOiccWGyeEnv19w7FMiw 